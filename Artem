import logging
import json
import uuid
from typing import List, Dict, Any

import httpx
from geopy.distance import geodesic

from telegram import (
    Update,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)

# ======================== –ù–ê–°–¢–†–û–ô–ö–ò ===========================
TOKEN = "8494036212:AAHNR8u-nqAmKHZV_QmOlL0yZDfmcpVPeCI"

ADMIN_IDS = [348516917, 343772891]

QUESTIONS_FILE = "questions.json"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# ======================== –•–†–ê–ù–ï–ù–ò–ï –î–ê–ù–ù–´–• ======================
def load_questions():
    try:
        with open(QUESTIONS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return []


def save_questions(data):
    with open(QUESTIONS_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


# ======================== –ö–ù–û–ü–ö–ò ==============================
def get_main_keyboard(is_admin=False):
    kb = [
        ["üí¨ –ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞"],
        ["üíä –°–∞–π—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞ –ø—Ä–µ–ø–∞—Ä–∞—Ç–æ–≤"],
        ["üìç –ê–ø—Ç–µ–∫–∏ —Ä—è–¥–æ–º"],
    ]
    if is_admin:
        kb.append(["‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"])

    return ReplyKeyboardMarkup(kb, resize_keyboard=True)


# ======================== START ================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.message.chat_id
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_keyboard(uid in ADMIN_IDS),
    )


# ======================== –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ò =========================
async def handle_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    uid = update.message.chat_id

    # –ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è
    if text == "üí¨ –ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞":
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å:", reply_markup=ReplyKeyboardRemove())
        context.user_data["awaiting_question"] = True
        return

    # ‚Äî –í–≤–æ–¥ –≤–æ–ø—Ä–æ—Å–∞ ‚Äî
    if context.user_data.get("awaiting_question"):
        context.user_data.pop("awaiting_question")

        questions = load_questions()

        qid = str(uuid.uuid4())
        question_text = update.message.text

        questions.append({
            "id": qid,
            "user_id": uid,
            "question": question_text,
            "status": "–Ω–æ–≤—ã–π",
        })
        save_questions(questions)

        # –æ—Ç–ø—Ä–∞–≤–∫–∞ –∞–¥–º–∏–Ω–∞–º
        for admin in ADMIN_IDS:
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("–û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"reply:{qid}")]
            ])
            await context.bot.send_message(
                chat_id=admin,
                text=f"üì© –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å –æ—Ç {uid}\n\n{question_text}",
                reply_markup=kb,
            )

        await update.message.reply_text(
            "–í–∞—à –≤–æ–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—É!",
            reply_markup=get_main_keyboard(uid in ADMIN_IDS),
        )
        return

    # –°–∞–π—Ç
    if text == "üíä –°–∞–π—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞ –ø—Ä–µ–ø–∞—Ä–∞—Ç–æ–≤":
        await update.message.reply_text(
            "–°–∞–π—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞: https://pharma.by",
            reply_markup=get_main_keyboard(uid in ADMIN_IDS),
        )
        return

    # –ê–ø—Ç–µ–∫–∏
    if text == "üìç –ê–ø—Ç–µ–∫–∏ —Ä—è–¥–æ–º":
        kb = ReplyKeyboardMarkup(
            [[{"text": "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", "request_location": True}]],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        context.user_data["awaiting_location"] = True
        await update.message.reply_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é:", reply_markup=kb)
        return

    # –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
    if uid in ADMIN_IDS and text == "‚öôÔ∏è –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å":
        await show_admin_panel(update, context)
        return


# ======================== –ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨ =========================
async def show_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    questions = load_questions()

    if not questions:
        await update.message.reply_text("–ù–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤.")
        return

    kb = []
    for q in questions:
        mark = "üÜï" if q["status"] == "–Ω–æ–≤—ã–π" else "‚úîÔ∏è"
        kb.append([InlineKeyboardButton(f"{mark} {q['user_id']}", callback_data=f"show:{q['id']}")])

    await update.message.reply_text(
        "–°–ø–∏—Å–æ–∫ –≤–æ–ø—Ä–æ—Å–æ–≤:",
        reply_markup=InlineKeyboardMarkup(kb)
    )


# ======================== INLINE-–ö–ù–û–ü–ö–ò ========================
async def inline_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    cmd, qid = query.data.split(":", 1)

    questions = load_questions()

    # –ø–æ–∫–∞–∑–∞—Ç—å –≤–æ–ø—Ä–æ—Å
    if cmd == "show":
        for q in questions:
            if q["id"] == qid:
                kb = InlineKeyboardMarkup([
                    [InlineKeyboardButton("–û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"reply:{qid}")]
                ])
                await query.message.reply_text(
                    f"–í–æ–ø—Ä–æ—Å:\n{q['question']}\n–°—Ç–∞—Ç—É—Å: {q['status']}",
                    reply_markup=kb,
                )
                return

    # –Ω–∞—á–∞—Ç—å –æ—Ç–≤–µ—Ç
    if cmd == "reply":
        context.user_data["reply_to"] = qid
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:")
        return


# ======================== –û–¢–í–ï–¢ –ê–î–ú–ò–ù–ê =========================
async def handle_admin_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.message.chat_id
    if uid not in ADMIN_IDS:
        return

    if "reply_to" not in context.user_data:
        return

    qid = context.user_data.pop("reply_to")

    questions = load_questions()

    # –∏—â–µ–º –≤–æ–ø—Ä–æ—Å
    for q in questions:
        if q["id"] == qid:
            user_id = q["user_id"]

            # –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            if update.message.text:
                await update.message.bot.send_message(
                    chat_id=user_id,
                    text=f"üì® –û—Ç–≤–µ—Ç —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞:\n{update.message.text}"
                )
            elif update.message.photo:
                await update.message.bot.send_photo(
                    chat_id=user_id,
                    photo=update.message.photo[-1].file_id,
                    caption="üì® –û—Ç–≤–µ—Ç —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞"
                )
            elif update.message.document:
                await update.message.bot.send_document(
                    chat_id=user_id,
                    document=update.message.document.file_id,
                    caption="üì® –û—Ç–≤–µ—Ç —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞"
                )

            # –û–ë–ù–û–í–õ–Ø–ï–ú –°–¢–ê–¢–£–°
            q["status"] = "–æ—Ç–≤–µ—á–µ–Ω"
            save_questions(questions)

            # —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω—É
            await update.message.reply_text("–û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!")

            # –∫–Ω–æ–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await update.message.bot.send_message(
                chat_id=user_id,
                text="–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å:",
                reply_markup=get_main_keyboard(user_id in ADMIN_IDS),
            )
            return


# ======================== –ì–ï–û–õ–û–ö–ê–¶–ò–Ø ==========================
async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get("awaiting_location"):
        return
    context.user_data.pop("awaiting_location")

    loc = update.message.location
    user_coords = (loc.latitude, loc.longitude)

    overpass_query = f"""
    [out:json][timeout:25];
    (
      node["amenity"="pharmacy"](around:2000,{loc.latitude},{loc.longitude});
      way["amenity"="pharmacy"](around:2000,{loc.latitude},{loc.longitude});
    );
    out center;
    """

    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.post("https://overpass-api.de/api/interpreter", data=overpass_query)
        data = r.json()

    if not data.get("elements"):
        await update.message.reply_text("–ê–ø—Ç–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã üòî")
        return

    results = []
    for e in data["elements"]:
        if "lat" in e:
            coords = (e["lat"], e["lon"])
        else:
            coords = (e["center"]["lat"], e["center"]["lon"])

        name = e.get("tags", {}).get("name", "–ê–ø—Ç–µ–∫–∞")
        dist = int(geodesic(user_coords, coords).meters)

        results.append((dist, name, coords))

    results.sort(key=lambda x: x[0])

    for dist, name, (la, lo) in results[:10]:
        await update.message.bot.send_venue(
            chat_id=update.message.chat_id,
            latitude=la,
            longitude=lo,
            title=name,
            address=f"{name} ‚Äî {dist} –º"
        )

    await update.message.reply_text(
        "–ì–æ—Ç–æ–≤–æ!",
        reply_markup=get_main_keyboard(update.message.chat_id in ADMIN_IDS),
    )


# ======================== –ó–ê–ü–£–°–ö ===============================
def main():
    app = (
        ApplicationBuilder()
        .token(TOKEN)
        .connect_timeout(15)
        .read_timeout(25)
        .build()
    )

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(inline_callback))
    app.add_handler(MessageHandler(filters.LOCATION, handle_location))
    app.add_handler(MessageHandler(filters.TEXT | filters.PHOTO | filters.Document.ALL, handle_admin_response))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    app.run_polling(stop_signals=None)


if __name__ == "__main__":
    main()
